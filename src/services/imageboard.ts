import {
  Community,
  GetCommentsRequest,
  GetCommentsResponse,
  GetCommunitiesRequest,
  GetCommunitiesResponse,
  GetCommunityRequest,
  GetCommunityResponse,
  GetFeedRequest,
  GetFeedResponse,
  GetInstancesResponse,
  Instance,
  Post,
} from "@/plugintypes";
import { ServiceType } from "@/types";
import Imageboard from "imageboard/browser";
import type { Thread, Comment, ImageboardId, ImageboardOptionsWithHttpRequestFunction } from "imageboard";
import { createHttpRequestFunction } from "imageboard";
import { doesAttachmentHavePicture, getAttachmentThumbnailSize } from "social-components/attachment";

const pluginName = "imageboard";
const corsProxy = process.env.NODE_ENV === "development" ? "http://localhost:8085/" : "https://vercelcors-elijahgreen-info-gata.vercel.app/api?url=";

// Supported imageboards as instances (using library's supported IDs)
const SUPPORTED_IMAGEBOARDS: Instance[] = [
  {
    name: "4chan",
    description: "The most popular English-language imageboard",
    url: "https://4chan.org",
    apiId: "4chan",
  },
  {
    name: "2ch.hk",
    description: "Russian imageboard",
    url: "https://2ch.hk",
    apiId: "2ch",
  },
  {
    name: "kohlchan",
    description: "German imageboard",
    url: "https://kohlchan.net",
    apiId: "kohlchan",
  },
  {
    name: "lainchan",
    description: "Cyberpunk and technology imageboard",
    url: "https://lainchan.org",
    apiId: "lainchan",
  },
  {
    name: "leftypol",
    description: "Leftist political imageboard",
    url: "https://leftypol.org",
    apiId: "leftypol",
  },
  {
    name: "endchan",
    description: "Free speech imageboard",
    url: "https://endchan.net",
    apiId: "endchan",
  },
];

/**
 * Convert imageboard content to HTML
 * The content field from the imageboard library uses ContentBlock[][] from 'social-components'
 * (array of paragraphs, each paragraph is an array of content blocks)
 */
const contentToHtml = (content: unknown): string => {
  if (!content) return "";
  if (typeof content === "string") return content;
  if (Array.isArray(content)) {
    // Content is an array of paragraphs
    return content
      .map((paragraph: unknown) => {
        if (typeof paragraph === "string") return paragraph;
        if (Array.isArray(paragraph)) {
          // Each paragraph is an array of content blocks
          const paragraphHtml = paragraph
            .map((item: unknown) => {
              if (typeof item === "string") return item;
              if (typeof item === "object" && item !== null) {
                const obj = item as { type?: string; content?: string; url?: string; meta?: { boardId?: string; threadId?: number; postId?: number } };
                if (obj.type === "text") {
                  return obj.content || "";
                }
                if (obj.type === "link") {
                  const url = obj.url || "#";
                  const text = obj.content || url;
                  return `<a href="${url}" class="text-primary hover:underline" target="_blank" rel="noopener noreferrer">${text}</a>`;
                }
                if (obj.type === "quote") {
                  return `<span class="text-green-600">&gt;${obj.content || ""}</span>`;
                }
                if (obj.type === "post-link") {
                  const commentId = (obj.meta as { commentId?: number })?.commentId;
                  const postId = commentId ? String(commentId) : "";
                  return `<a href="#" class="text-primary hover:underline">&gt;&gt;${postId}</a>`;
                }
              }
              return "";
            })
            .join("");
          return paragraphHtml;
        }
        return "";
      })
      .join("<br>");
  }
  return "";
};

/**
 * Extract image/video URL from attachment
 */
const getAttachmentUrl = (attachment: import("imageboard").Attachment): string | undefined => {
  if (attachment.type === "picture" && "picture" in attachment) {
    return attachment.picture.url;
  }
  if (attachment.type === "video" && "video" in attachment) {
    return attachment.video.url;
  }
  return undefined;
};

/**
 * Convert imageboard thread to Post
 */
const imageboardThreadToPost = (
  thread: Thread,
  instanceId: string
): Post => {
  const firstComment = thread.comments?.[0];
	const thumbnailAttachment = firstComment?.attachments &&
			firstComment.attachments.filter(doesAttachmentHavePicture)[0]
  const thumbnail = thumbnailAttachment ? getAttachmentThumbnailSize(thumbnailAttachment) : undefined;
  const thumbnailUrl = thumbnail ? thumbnail.url : undefined;
  const firstAttachment = firstComment?.attachments?.[0];
  const attachmentUrl = firstAttachment ? getAttachmentUrl(firstAttachment) : undefined;

  return {
    apiId: String(thread.id),
    title: thread.title || thread.autogeneratedTitle || `Thread #${thread.id}`,
    body: firstComment ? contentToHtml(firstComment.content) : undefined,
    publishedDate: thread.createdAt?.toISOString(),
    communityApiId: thread.boardId,
    communityName: `/${thread.boardId}/`,
    authorName: firstComment?.authorName || "Anonymous",
    authorApiId: firstComment?.authorId,
    pluginId: pluginName,
    instanceId: instanceId,
    thumbnailUrl: thumbnailUrl,
    url: attachmentUrl,
    numOfComments: thread.commentsCount,
    number: Number(thread.id),
  };
};

/**
 * Convert imageboard comment to Post (for comment trees)
 */
const imageboardCommentToPost = (
  comment: Comment,
  instanceId: string
): Post => {
  const thumbnailAttachment = comment.attachments &&
    comment.attachments.filter(doesAttachmentHavePicture)[0];
  const thumbnail = thumbnailAttachment ? getAttachmentThumbnailSize(thumbnailAttachment) : undefined;
  const thumbnailUrl = thumbnail ? thumbnail.url : undefined;
  const firstAttachment = comment.attachments?.[0];
  const attachmentUrl = firstAttachment ? getAttachmentUrl(firstAttachment) : undefined;

  const bodyHtml = contentToHtml(comment.content);

  return {
    apiId: String(comment.id),
    body: bodyHtml,
    publishedDate: comment.createdAt?.toISOString(),
    authorName: comment.authorName || "Anonymous",
    authorApiId: comment.authorId,
    pluginId: pluginName,
    instanceId: instanceId,
    thumbnailUrl: thumbnailUrl,
    url: attachmentUrl,
    number: Number(comment.id),
  };
};

class ImageboardService implements ServiceType {
  platformType = "imageboard" as const;

  /**
   * Get list of supported imageboards as instances
   */
  async getInstances(): Promise<GetInstancesResponse> {
    return {
      instances: SUPPORTED_IMAGEBOARDS,
    };
  }

  private getImageboard = (instanceId: string): Imageboard => {
    const sendHttpRequest = createHttpRequestFunction({
      fetch: fetch,
      FormData: FormData,
      getRequestUrl: (parameters: { url: string }) => {
        return `${corsProxy}${parameters.url}`;
      },
    });
    const options: ImageboardOptionsWithHttpRequestFunction = {
      sendHttpRequest,
    }
    return Imageboard(instanceId as ImageboardId, 
      options,
    );
  }

  /**
   * Get feed of threads from a board
   */
  async getFeed(request: GetFeedRequest): Promise<GetFeedResponse> {
    const instanceId = request.instanceId || "4chan";
    const boardId = request.feedTypeId || "g"; // Default to /g/ (technology)

    try {
      const imageboard = this.getImageboard(instanceId);

      // Check if imageboard supports getThreads
      if (!imageboard.getThreads) {
        throw new Error(`${instanceId} does not support getting threads`);
      }

      const threadsResponse = await imageboard.getThreads({
        boardId: boardId,
      });

      const threads = threadsResponse.threads || [];
      const items = threads.map((thread) =>
        imageboardThreadToPost(thread, instanceId)
      );

      return {
        items,
        pageInfo: {
          page: 1,
        },
      };
    } catch (error) {
      console.error("Error fetching imageboard feed:", error);
      return {
        items: [],
        pageInfo: {},
      };
    }
  }

  /**
   * Get board info and threads
   */
  async getCommunity(request: GetCommunityRequest): Promise<GetCommunityResponse> {
    const instanceId = request.instanceId || "4chan";
    const boardId = request.apiId;

    try {
      const imageboard = this.getImageboard(instanceId);

      // Get threads for this board
      const threadsResponse = await imageboard.getThreads({
        boardId: boardId,
      });

      const threads = threadsResponse.threads || [];
      const items = threads.map((thread) =>
        imageboardThreadToPost(thread, instanceId)
      );

      // Use board info from response if available
      const boardInfo = threadsResponse.board;

      return {
        community: {
          apiId: boardId,
          name: boardInfo?.title || `/${boardId}/`,
          instanceId: instanceId,
        },
        items,
        pageInfo: {},
      };
    } catch (error) {
      console.error("Error fetching imageboard community:", error);
      return {
        community: {
          apiId: boardId,
          name: `/${boardId}/`,
          instanceId: instanceId,
        },
        items: [],
        pageInfo: {},
      };
    }
  }

  /**
   * Get list of all boards/communities for an imageboard instance
   */
  async getCommunities(request: GetCommunitiesRequest): Promise<GetCommunitiesResponse> {
    const instanceId = request.instanceId || "4chan";

    try {
      const imageboard = this.getImageboard(instanceId);

      // Check if imageboard supports getBoards
      if (!imageboard.getBoards) {
        throw new Error(`${instanceId} does not support getting boards`);
      }

      const boardsResponse = await imageboard.getBoards();
      const boards = boardsResponse.boards || [];

      const communities: Community[] = boards.map((board) => ({
        apiId: board.id,
        name: board.title || `/${board.id}/`,
        instanceId: instanceId,
      }));

      return {
        items: communities,
        pageInfo: {},
      };
    } catch (error) {
      console.error("Error fetching imageboard communities:", error);
      return {
        items: [],
        pageInfo: {},
      };
    }
  }

  /**
   * Get thread with all comments
   */
  async getComments(request: GetCommentsRequest): Promise<GetCommentsResponse> {
    const instanceId = request.instanceId || "4chan";
    const threadId = request.apiId;
    const boardId = request.communityId;

    if (!threadId || !boardId) {
      throw new Error("Both threadId and boardId are required");
    }

    try {
      const imageboard = this.getImageboard(instanceId);

      const threadResponse = await imageboard.getThread({
        boardId: boardId,
        threadId: Number(threadId),
      });

      const thread = threadResponse.thread;

      // First comment is the OP (original post)
      const opComment = thread.comments?.[0];
      const firstAttachment = opComment?.attachments?.[0];
      const attachmentUrl = firstAttachment ? getAttachmentUrl(firstAttachment) : undefined;

      const post: Post = {
        apiId: String(thread.id),
        title: thread.title || thread.autogeneratedTitle || `Thread #${thread.id}`,
        body: opComment ? contentToHtml(opComment.content) : undefined,
        publishedDate: thread.createdAt?.toISOString(),
        communityApiId: thread.boardId,
        communityName: `/${thread.boardId}/`,
        authorName: opComment?.authorName || "Anonymous",
        authorApiId: opComment?.authorId,
        pluginId: pluginName,
        instanceId: instanceId,
        thumbnailUrl: attachmentUrl,
        url: attachmentUrl,
        numOfComments: thread.commentsCount,
        number: Number(thread.id),
      };

      // Rest are comments (skip first comment which is OP)
      const comments = thread.comments?.slice(1) || [];
      const items = comments.map((comment) =>
        imageboardCommentToPost(comment, instanceId)
      );

      return {
        post,
        items,
        community: {
          apiId: boardId,
          name: threadResponse.board?.title || `/${boardId}/`,
          instanceId: instanceId,
        },
        pageInfo: {},
      };
    } catch (error) {
      console.error("Error fetching imageboard comments:", error);
      throw error;
    }
  }
}

export default new ImageboardService();
